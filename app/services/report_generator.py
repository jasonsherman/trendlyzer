"""
Service for generating PDF reports with charts.
"""
import os
import matplotlib
matplotlib.use('Agg')  # Set the backend to non-interactive 'Agg'
import matplotlib.pyplot as plt
from fpdf import FPDF
from fpdf.enums import XPos, YPos
from wordcloud import WordCloud
from typing import List, Dict, Tuple
import logging
from ..models.report_metrics import ReportMetrics
from ..config.config import REPORT_CONFIG, REPORTS_FOLDER
from flask import current_app

logger = logging.getLogger(__name__)

class ReportGenerator:
    """Class responsible for generating PDF reports with charts."""

    def __init__(self, filename: str, company_name: str):
        """Initialize the report generator."""
        self.filename = filename
        self.company_name = company_name
        self.pdf = FPDF()
        self._setup_fonts()

    def _setup_fonts(self):
        """Register fonts for the PDF."""
        self.pdf.add_font(
            REPORT_CONFIG['font']['name'],
            '',
            REPORT_CONFIG['font']['regular'],
            uni=True
        )
        self.pdf.add_font(
            REPORT_CONFIG['font']['name'],
            'B',
            REPORT_CONFIG['font']['bold'],
            uni=True
        )
        self.pdf.add_font(
            REPORT_CONFIG['font']['name'],
            'I',
            REPORT_CONFIG['font']['italic'],
            uni=True
        )

    def _add_header(self):
        """Add header section to the report."""
        self.pdf.add_page()
        logo_path = 'static/images/trendlyzer-report-logo.png'

        if os.path.exists(logo_path):
            self.pdf.image(logo_path, x=80, y=10, w=50)
            self.pdf.ln(30)
        else:
            self.pdf.ln(20)

        self.pdf.set_font(REPORT_CONFIG['font']['name'], "B", 16)
        self.pdf.cell(
            0, 7, "Trend Analyzer & Insights Report",
            new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C'
        )

    def _create_chart(self, data: Dict[str, float], title: str, filename: str, chart_type: str = 'bar') -> str:
        """Create a chart and save it (supports bar/line/pie/table)."""
        plt.figure(figsize=REPORT_CONFIG['charts']['default_size'])

        if chart_type == 'pie':
            plt.pie(list(data.values()), labels=list(data.keys()), autopct='%1.1f%%')
            plt.title(title)
        elif chart_type == 'line':
            plt.plot(list(data.keys()), list(data.values()), marker='o')
            plt.title(title)
            plt.ylabel('Value')
            plt.xticks(rotation=20, ha='right')
        elif chart_type == 'table':
            plt.axis('off')
            cell_text = [[k, v] for k, v in data.items()]
            col_labels = ['Label', 'Value']
            plt.table(cellText=cell_text, colLabels=col_labels, loc='center')
            plt.title(title)
        else:
            plt.bar(data.keys(), data.values(), color=REPORT_CONFIG['charts']['bar_color'])
            plt.title(title)
            plt.ylabel('Value')
            plt.xticks(rotation=20, ha='right')
        plt.tight_layout()

        chart_path = os.path.join(REPORTS_FOLDER, filename)
        os.makedirs(os.path.dirname(chart_path), exist_ok=True)
        plt.savefig(chart_path)
        plt.close()
        return chart_path

    def _add_section(self, title: str, content: str):
        """Add a section to the report."""
        self.pdf.set_font(REPORT_CONFIG['font']['name'], "B", 14)
        self.pdf.set_text_color(*REPORT_CONFIG['colors']['primary'])
        self.pdf.cell(0, 7, title, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        self.pdf.set_text_color(0, 0, 0)
        self.pdf.set_font(REPORT_CONFIG['font']['name'], "", 12)
        self.pdf.multi_cell(0, 7, content)
        self.pdf.ln(8)

    def _add_wordcloud(self, text: str):
        """Add word cloud to the report."""
        wc_path = os.path.join(
            REPORTS_FOLDER, f"{os.path.basename(self.filename).replace('.txt', '')}_wordcloud.png")
        wc = WordCloud(width=800, height=400, background_color='white').generate(text)
        wc.to_file(wc_path)
        self.pdf.image(wc_path, w=110)
        self.pdf.ln(10)

    def _add_footer(self):
        """Add footer to the report."""
        self.pdf.set_y(self.pdf.get_y() + 5)
        self.pdf.set_font(REPORT_CONFIG['font']['name'], 'I', 8)
        self.pdf.cell(
            0, 10, 'Generated by Trendlyzer | VengoAI.com', 0, 1, 'C')

    def _get_visualizations(self, viz_analysis_json):
        """Extract visualizations from the analysis JSON, handling both formats.
        
        Args:
            viz_analysis_json: The visualization analysis JSON
            
        Returns:
            list: List of visualization objects
        """
        try:
            if isinstance(viz_analysis_json, list):
                current_app.logger.info("Visualization data is a direct array")
                return viz_analysis_json
            current_app.logger.info("Visualization data is nested under 'visualizations' key")
            return viz_analysis_json.get('visualizations', [])
        except Exception as e:
            current_app.logger.error(f"Error extracting visualizations: {str(e)}")
            return []

    def generate(
        self,
        mode: str,
        metrics: ReportMetrics,
    ) -> Tuple[str, str]:
        """Generate the complete report."""
        try:
            current_app.logger.info(f"Starting report generation for {self.filename}")
            self._add_header()
            
            self._generate_report(metrics, mode)

            if not os.path.exists(REPORTS_FOLDER):
                current_app.logger.info(f"Creating reports directory: {REPORTS_FOLDER}")
                os.makedirs(REPORTS_FOLDER)
                
            report_filename = f"{os.path.basename(self.filename).replace('.txt', '')}_report.pdf"
            report_path = os.path.join(REPORTS_FOLDER, report_filename)
            current_app.logger.info(f"Saving report to: {report_path}")
            self.pdf.output(report_path)
            web_report_path = f"/app/static/reports/{report_filename}"
            
            overview = self._generate_overview(metrics)
            current_app.logger.info("Report generation completed successfully")
            return web_report_path, overview
            
        except Exception as e:
            current_app.logger.error(f"Error generating report: {str(e)}")
            raise
    
    def _get_chart_data_for_viz(self, viz, ai_analysis_json):
        """
        Dynamically builds the chart data dict for a visualization suggestion,
        matching data_points/labels to key_metrics entries using linked_metric and possible name patterns.
        """
        try:
            current_app.logger.info(f"Building chart data for visualization: {viz.get('id', 'unknown')}")
            chart_data = {}
            key_metrics = ai_analysis_json.get("key_metrics", {})
            current_app.logger.info(f"Available metric types: {list(key_metrics.keys())}")

            # Build a single list of all metrics (financial, performance, other_metrics)
            all_metrics = []
            for metric_type in ["financial", "performance", "other_metrics"]:
                metrics = key_metrics.get(metric_type, [])
                all_metrics.extend(metrics)
                current_app.logger.info(f"Added {len(metrics)} metrics from {metric_type}")

            current_app.logger.info(f"Total metrics available for matching: {len(all_metrics)}")

            # Try to match each label in data_points to a metric by name, label, or category
            for label in viz.get("data_points", []):
                current_app.logger.info(f"Processing data point: {label}")
                value = None
                possible_names = [
                    f"{label} {viz['linked_metric']}".strip().lower(),
                    f"{viz['linked_metric']} {label}".strip().lower(),
                    label.strip().lower(),
                    viz['linked_metric'].strip().lower()
                ]
                current_app.logger.info(f"Generated possible names for matching: {possible_names}")

                # Search through all available metrics for the first match
                for metric in all_metrics:
                    metric_name = metric.get('name', '').strip().lower()
                    # Try to match based on generated naming conventions
                    if metric_name in possible_names:
                        value = metric.get('value', 0)
                        current_app.logger.info(f"Found exact match for '{label}' in metric: {metric_name}")
                        break
                    # Also allow loose containment match as fallback (e.g., 'Advanced Plan' in metric_name)
                    if label.strip().lower() in metric_name and viz['linked_metric'].strip().lower() in metric_name:
                        value = metric.get('value', 0)
                        current_app.logger.info(f"Found partial match for '{label}' in metric: {metric_name}")
                        break
                    if label.strip().lower() == metric_name:
                        value = metric.get('value', 0)
                        current_app.logger.info(f"Found direct match for '{label}' with metric: {metric_name}")
                        break

                if value is None:
                    current_app.logger.warning(f"No match found for data point: {label}, using default value 0")
                chart_data[label] = value if value is not None else 0

            current_app.logger.info(f"Completed chart data generation with {len(chart_data)} data points")
            return chart_data

        except Exception as e:
            current_app.logger.error(f"Error generating chart data: {str(e)}")
            return {}

    def _generate_conversational_report(self, metrics: ReportMetrics):
        """Generate report for conversational documents."""

        # Key Highlights
        highlights = (
            f"- Total Conversations Analyzed: {metrics.total_conversations}\n"
            f"- Email Leads Collected: {metrics.email_conversion_rate:.2f}%\n"
            f"- Phone Numbers Collected: {metrics.phone_conversion_rate:.2f}%"
        )
        self._add_section("Key Highlights", highlights)

        # Lead Capture Rates Chart
        chart_data = {
            'Email Leads': metrics.email_conversion_rate,
            'Phone Numbers': metrics.phone_conversion_rate
        }
        chart_path = self._create_chart(
            chart_data,
            'Lead Capture Rates',
            f"{os.path.basename(self.filename).replace('.txt', '')}_lead_capture.png"
        )
        self.pdf.image(chart_path, w=110)
        self.pdf.ln(10)

        # Top 3 Lead Capture Metrics
        lead_metrics = (
            f"- {metrics.email_conversion_rate:.2f}% of customers provided an email after chatting\n"
            f"- {metrics.phone_conversion_rate:.2f}% of customers provided a phone number\n"
            f"- Over {metrics.follow_up_rate:.0f}% of all conversations led to actionable follow-ups"
        )
        self._add_section("Top 3 Lead Capture Metrics", lead_metrics)

        # Top Lead Capture Metrics Chart
        lead_chart_data = {
            'Email Provided': metrics.email_conversion_rate,
            'Phone Provided': metrics.phone_conversion_rate,
            'Follow-Ups': metrics.follow_up_rate
        }
        lead_chart_path = self._create_chart(
            lead_chart_data,
            'Top Lead Capture Metrics',
            f"{os.path.basename(self.filename).replace('.txt', '')}_top_lead_metrics.png"
        )
        self.pdf.image(lead_chart_path, w=110)
        self.pdf.ln(10)


        # Visual Insights Chart
        vis_chart_data = {
            'Lead Capture Success': metrics.lead_success_rate,
            'Customer Readiness': metrics.readiness_rate,
            'Trust Concerns': metrics.trust_rate
        }
        vis_chart_path = self._create_chart(
            vis_chart_data,
            'Business Trends Observed',
            f"{os.path.basename(self.filename).replace('.txt', '')}_trends_impact.png"
        )
        self.pdf.image(vis_chart_path, w=110)
        self.pdf.ln(10)


    def _generate_report(self, metrics: ReportMetrics, mode: str):
        """Generate report for normal documents."""
        try:
            # --- Header & Executive Summary ---
            ai_analysis_json = metrics.ai_analysis
            viz_analysis_json = ai_analysis_json.get("visualizations", [])
            current_app.logger.info(f"AI Analysis available: {bool(ai_analysis_json)}")
            current_app.logger.info(f"Visualization suggestions available: {bool(viz_analysis_json)}")

            doc_type = ai_analysis_json.get('document_type', 'Document') if ai_analysis_json else 'Document'
            exec_summary = ai_analysis_json.get('executive_summary', '') if ai_analysis_json else ''

            self._add_section(f"{doc_type} Executive Summary", exec_summary)

            if mode == "Conversational Document":
                current_app.logger.info("Including conversation content")
                self._generate_conversational_report(metrics)

            if ai_analysis_json:
                current_app.logger.info("Processing AI analysis sections")
                sentiment = ai_analysis_json.get('sentiment', {})
                overall_sentiment = sentiment.get('overall', 'neutral')
                sentiment_conf = sentiment.get('confidence', 0)
                highlights = "\n".join(
                    f"- {h['text']} ({h['sentiment']})"
                    for h in sentiment.get('highlights', [])
                )
                self._add_section("Sentiment Analysis",
                    f"Overall: {overall_sentiment} (Confidence: {sentiment_conf:.2f})\nHighlights:\n{highlights}"
                )
                self._add_section("Key Topics", "\n".join(
                    f"- {t['topic']} ({t['coverage_pct']:.1f}%)" for t in ai_analysis_json.get('key_topics', [])
                ))
                self._add_section("Themes & Phrases", "\n".join(
                    f"- {th['phrase']} (Weight: {th['weight']:.2f})" for th in ai_analysis_json.get('themes', [])
                ))
                # Key Metrics Table
                key_metrics = ai_analysis_json.get('key_metrics', {})
                for metric_type, metrics_list in key_metrics.items():
                    if metrics_list:
                        metric_lines = [
                            f"{m['name']}: {m['value']} {m['unit']} ({m['period']})"
                            for m in metrics_list
                        ]
                        self._add_section(f"{metric_type.title()} Metrics", "\n".join(metric_lines))

                # Recommendations
                recs = ai_analysis_json.get('recommendations', [])
                if recs:
                    self._add_section("AI Recommendations", "\n".join(
                        f"{r['id']}: {r['text']} (Impact: {r['impact']}, Effort: {r['effort']})" for r in recs
                    ))
                
                # Detailed Analysis Sections
                for section in ai_analysis_json.get('detailed_analysis', []):
                    self._add_section(section.get('heading', ''), section.get('summary', ''))
            
            # --- Visualizations ---
            if viz_analysis_json:
                current_app.logger.info("Processing visualization suggestions")
                visualizations = self._get_visualizations(viz_analysis_json)
                current_app.logger.info(f"Found {len(visualizations)} visualizations to process")
                
                for viz in visualizations:
                    try:
                        # 1. Try to create a chart for each visualization suggestion
                        chart_title = viz.get('title', '')
                        chart_type = viz.get('type', 'bar')
                        data_points = viz.get('data_points', [])
                        linked_metric = viz.get('linked_metric', '')
                        purpose = viz.get('purpose', '')

                        current_app.logger.info(f"Creating chart: {chart_title} ({chart_type})")
                        
                        if data_points and isinstance(data_points[0], dict) and 'label' in data_points[0] and 'value' in data_points[0]:
                            current_app.logger.info("Using LLM generated datapoints")
                            chart_data = {dp['label']: dp['value'] for dp in data_points}
                        else:
                            current_app.logger.info("LLM generated datapoints not found!!")
                            # Extract data for the suggested data_points/metrics from ai_analysis_json
                            value_map = {m['period']: m['value']
                                        for m in ai_analysis_json.get('key_metrics', {}).get('financial', [])
                                        if m['name'] == linked_metric}
                            chart_data = {period: value_map.get(period, 0) for period in data_points}   
                        # chart_data = self._get_chart_data_for_viz(viz, ai_analysis_json)

                        chart_path = self._create_chart(chart_data, chart_title, f"{viz['id']}_{self.filename}.png", chart_type=chart_type)
                        self._add_section(f"{chart_title}", f"Purpose: {purpose}")
                        self.pdf.image(chart_path, w=110)
                    except Exception as e:
                        current_app.logger.error(f"Error creating visualization {viz.get('id', 'unknown')}: {str(e)}")
                        continue
            
            self._add_section("Conclusion", ai_analysis_json.get('conclusion', '')) if ai_analysis_json else ""

            self._add_footer()
            current_app.logger.info("Normal report generation completed")
        except Exception as e:
            current_app.logger.error(f"Error in normal report generation: {str(e)}")
            raise

    def _generate_overview(self, metrics):
        """Generate overview text for the report."""
        return (
            f"This report was created for {self.company_name} as a {metrics.mode.lower()} containing approximately "
            f"{metrics.word_count:,} words and {metrics.line_count:,} lines. "
            f"{metrics.ai_analysis.get('executive_summary', '') if metrics.ai_analysis else ''}"
        ) 